import numpy as np
import pandas as pd
import os
import warnings

from Bio.PDB import MMCIFParser, PDBParser, Superimposer
from itertools import combinations

class AlignmentTool:
    """
    Offer methods to calculate aligned RMSD for co-folding models
    """
    def __init__(self):
        super().__init__()
        self._cif_parser = MMCIFParser(QUIET=True)
        self._pdb_parser = PDBParser(QUIET=True)
        self._superimposer = Superimposer()

    def align_and_calculate_rmsd(self, structure_files, chain_ids=['A', 'B', 'C']):
        """
        Calculate average pair-wise peptide RMSD for candidates generated by co-folding models.

        :param structure_files: path containing co-folded structures (or best candidate + reference)
        :param chain_ids: default to represent alpha, beta and peptide

        :return the value of average_rmsd
        """
        structures = [self._load_structure(cif_file) for cif_file in structure_files]
        ca_atoms_list = [self._get_ca_atoms(structure, chain_ids) for structure in structures]
        C_chain_len = len(self._get_ca_atoms(structures[0], ['C']))
        ref_atoms = ca_atoms_list[0]
        # assert len(ca_atoms_list) > 1
        for i in range(1, len(ca_atoms_list)):
            self._align_structures(ref_atoms, ca_atoms_list[i], C_chain_len)
        pairwise_rmsds = []
        for (i, atoms1), (j, atoms2) in combinations(enumerate(ca_atoms_list), 2):
            rmsd = self._calculate_rmsd(atoms1, atoms2, C_chain_len)
            pairwise_rmsds.append(rmsd)
        average_rmsd = np.mean(pairwise_rmsds)
        return average_rmsd

    def iterative_align_and_calculate_rmsd(self, structure_files, chain_ids=['A', 'B', 'C']):
        """
        Iteratively align and alculate average pair-wise peptide RMSD
        for candidates generated by co-folding models.
        """
        structures = [self._load_structure(cif_file) for cif_file in structure_files]
        ca_atoms_list = [self._get_ca_atoms(structure, chain_ids) for structure in structures]
        C_chain_len = len(self._get_ca_atoms(structures[0], ['C']))
        # assert len(ca_atoms_list) > 1
        ref_atoms = ca_atoms_list[0]
        pairwise_rmsds = []
        for (i, atoms1), (j, atoms2) in combinations(enumerate(ca_atoms_list), 2):
            rmsd = self._iterative_align_structures(atoms1, atoms2, C_chain_len)
            pairwise_rmsds.append(rmsd)
        average_rmsd = np.mean(pairwise_rmsds)
        return average_rmsd

    def _load_structure(self, file):
        parser = self._cif_parser if ".cif" in str(file) else self._pdb_parser
        structure = parser.get_structure('structure', file)
        return structure

    def _get_ca_atoms(self, structure, chain_ids):
        ca_atoms = []
        for model in structure:
            for chain in model:
                if chain.id in chain_ids:
                    for residue in chain:
                        if 'CA' in residue:
                            ca_atoms.append(residue['CA'])
        return ca_atoms

    def _align_structures(self, ref_atoms, target_atoms, C_chain_len=0):
        # C_chain corresponds to peptide
        if C_chain_len == 0:
            self._superimposer.set_atoms(ref_atoms, target_atoms)
            warnings.warn("C chain has length zero.")
        elif C_chain_len > 0:
            self._superimposer.set_atoms(ref_atoms[:-C_chain_len], target_atoms[:-C_chain_len])
        self._superimposer.apply(target_atoms)

    def _calculate_rmsd(self, atoms1, atoms2, C_chain_len):
        if len(atoms1) != len(atoms2):
            raise ValueError("Number of CA atoms does not match.")
        if C_chain_len == 0:
            warnings.warn("C chain has length zero. Return framework RMSD instead.")
            return np.sqrt(np.mean([(a1 - a2) ** 2 for a1, a2 in zip(atoms1, atoms2)]))
        else:
            chose_C_atoms1 = atoms1[-C_chain_len:]
            chose_C_atoms2 = atoms2[-C_chain_len:]
            case_normal = np.sqrt(np.mean([(a1 - a2) ** 2 for a1, a2 in zip(chose_C_atoms1, chose_C_atoms2)]))
            # TODO: to define better metrics when inversion occurs
            case_inverted = np.sqrt(np.mean([(a1 - a2) ** 2 for a1, a2 in zip(chose_C_atoms1, chose_C_atoms2[::-1])]))
            return min(case_normal, case_inverted)
            # return case_normal

    def _iterative_align_structures(self, ref_atoms, target_atoms, C_chain_len, max_cycles=5, rejection_threshold=2.0):
        """
        Perform iterative alignment to best match the framework atoms

        :param ref_atoms: list of extracted reference atom coordinates
        :param target_atoms: list of extracted target atom coordinates
        :param C_chain_len: length of C chain
        :param max_cycles: max iterative cycles
        :param rejection_threshold: atoms larger than this threshold will be ignored in next iteration

        :return minimum C_chain RMSD
        """
        
        if C_chain_len == 0:
            warnings.warn("C chain has length zero. Return framework RMSD instead.")
            for cycle in range(max_cycles):
                self._superimposer.set_atoms(ref_atoms, target_atoms)
                self._superimposer.apply(target_atoms)
                distances = np.array([np.linalg.norm(a1.coord - a2.coord) for a1, a2 in zip(ref_atoms, target_atoms)])
                rmsd = np.sqrt(np.mean(distances ** 2))
                # print(f"Cycle {cycle + 1}: RMSD = {rmsd:.3f}")
                mask = distances < rejection_threshold
                ref_atoms = [a for a, m in zip(ref_atoms, mask) if m]
                target_atoms = [a for a, m in zip(target_atoms, mask) if m]
                if len(ref_atoms) == 0 or len(target_atoms) == 0:
                    raise ValueError("No atoms left after rejection.")
            
        elif C_chain_len > 0:
            for cycle in range(max_cycles):
                self._superimposer.set_atoms(ref_atoms[:-C_chain_len], target_atoms[:-C_chain_len])
                self._superimposer.apply(target_atoms)
                distances = np.array([np.linalg.norm(a1.coord - a2.coord) for a1, a2 in zip(ref_atoms[:-C_chain_len], target_atoms[:-C_chain_len])])
                rmsd = np.sqrt(np.mean(distances ** 2))
                # print(f"Cycle {cycle + 1}: RMSD = {rmsd:.3f}")
                mask = distances < rejection_threshold
                mask = list(mask) + [True] * C_chain_len
                ref_atoms = [a for a, m in zip(ref_atoms, mask) if m]
                target_atoms = [a for a, m in zip(target_atoms, mask) if m]
                if len(ref_atoms) == 0 or len(target_atoms) == 0:
                    raise ValueError("No atoms left after rejection.")
                chose_C_atoms1 = ref_atoms[-C_chain_len:]
                chose_C_atoms2 = target_atoms[-C_chain_len:]
                case_normal = np.sqrt(np.mean([(a1 - a2) ** 2 for a1, a2 in zip(chose_C_atoms1, chose_C_atoms2)]))
                # TODO: to define better metrics when inversion occurs
                # case_inverted = np.sqrt(np.mean([(a1 - a2) ** 2 for a1, a2 in zip(chose_C_atoms1, chose_C_atoms2[::-1])]))
                # rmsd = min(case_normal, case_inverted)
                rmsd = case_normal
        return rmsd

if __name__ == "__main__":
    """
    place the cofolded structures under ``gen_path_root''
    download parsed experimental pMHCII structures under 
    """
    gen_path_root = "PATH/OF/COFOLDED/STRUCTURES/ROOT"
    df_reference = pd.read_csv("./data/exp_data_info.csv", index_col=0)
    exp_structures_path = "./data/exp_data"
    all_gen_cofold = ["af3", "chai-1", "protenix"]
    
    def select_file(gen, pdb, num=5):
        # default to five candidates each; return list of file paths
        source_files = [os.path.join(gen_path_root, gen, pdb, i) for i in range(num)]
        return source_files
    
    df_reference["pep_len"] = df_reference["peptide_seq"].str.len()
    aligner = AlignmentTool()
    for gen in all_gen_cofold:
        df_reference[gen] = 0.0
        for filename in os.listdir(exp_structures_path):
            target_file = os.path.join(exp_structures_path, filename)
            pdb = filename.split("_")[0]
            assert len(pdb) == 4 # four digit pdb
            if pdb not in df_reference["pdb_name"].values:
                warnings.warn(f"The PDB {pdb.upper()} is not recorded.")
                continue
            # print("Processsing PDB:", pdb)
            source_files = gen_path_root(gen, pdb, num=5)
            records = [aligner.align_and_calculate_rmsd([source_file, target_file]) for source_file in source_files]
            iter_average_rmsd = min(records) 
            df_reference.loc[df_reference["pdb_name"] == pdb, gen] = round(iter_average_rmsd, 3) 
            df_reference.to_csv("../data/cofold_rmsd.csv", encoding='utf-8')